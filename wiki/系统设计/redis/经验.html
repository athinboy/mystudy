<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Redis经验</title>
</head>
<body>


<h6>来自www.cnblogs.com/yilezhu/p/9941208.html</h6>
<ul>
    <li>Redis异步尽量不用，因为Redis延迟本身很小，大概在100us-200us，再一个就是Redis本身是单线程的，异步任务切换的耗时比网络耗时还要大。List用法：物联网中数据上传，量比较大时，我们可以把这些数据先放在Redis的List中，比如说一秒钟1万条，然后再批量取出来然后批量插入数据库中。这时候要设置好key,可以前缀+时间，对于已经处理的List可以进行remove移除。</li>
    <li>在Linux上多实例部署，实例个数等于处理器个数，各实例最大内存直接为本机物理内存，避免单个实例内存撑爆（比方说8核心处理器，那么就部署8个实例）</li>
    <li>把海量数据（10亿+）根据key哈希（Crc16/Crc32）存放在多个实例上，读写性能成倍增长采用二进制序列化，而非常见的Json序列化</li>
    <li>合理设计每一对Key的Value大小，包括但不限于使用批量获取，原则是让每次网络包控制在1.4k字节附近，减少通信次数（实际经验几十k，几百k也是没问题的）</li>
    <li>Redis客户端的Get/Set操作平均耗时200~600us（含往返网络通信），以此为参考评估网络环境和Redis客户端组件（达不到就看一下网络，序列化方式等等）</li>
    <li>使用管道Pipeline合并一批命令</li>
    <li>Redis的主要性能瓶颈是序列化、网络带宽和内存大小，滥用时处理器也会达到瓶颈</li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>
    <li></li>

</ul>


<hr/>


</body>
</html>